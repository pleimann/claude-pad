package configpush

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/pleimann/camel-pad/internal/config"
)

const configFileName = "config.py"

// Push converts the config and writes it to the CIRCUITPY drive
func Push(cfg *config.Config) error {
	// Find CIRCUITPY mount point
	mountPoint, err := FindCIRCUITPY()
	if err != nil {
		return fmt.Errorf("failed to find CIRCUITPY drive: %w", err)
	}

	// Generate Python config content
	content, err := GeneratePythonConfig(cfg)
	if err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}

	// Write to device
	destPath := filepath.Join(mountPoint, configFileName)
	if err := os.WriteFile(destPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write config to %s: %w", destPath, err)
	}

	return nil
}

// FindCIRCUITPY locates the CIRCUITPY drive mount point
func FindCIRCUITPY() (string, error) {
	var candidates []string

	switch runtime.GOOS {
	case "darwin":
		candidates = []string{"/Volumes/CIRCUITPY"}
	case "linux":
		user := os.Getenv("USER")
		candidates = []string{
			filepath.Join("/media", user, "CIRCUITPY"),
			filepath.Join("/run/media", user, "CIRCUITPY"),
			"/mnt/CIRCUITPY",
		}
	case "windows":
		// Check common drive letters for CIRCUITPY volume
		for _, letter := range "DEFGHIJKLMNOPQRSTUVWXYZ" {
			candidates = append(candidates, fmt.Sprintf("%c:\\", letter))
		}
	default:
		return "", fmt.Errorf("unsupported operating system: %s", runtime.GOOS)
	}

	for _, path := range candidates {
		if runtime.GOOS == "windows" {
			// On Windows, we need to check the volume label
			if isWindowsCIRCUITPY(path) {
				return path, nil
			}
		} else {
			if info, err := os.Stat(path); err == nil && info.IsDir() {
				return path, nil
			}
		}
	}

	return "", fmt.Errorf("CIRCUITPY drive not found (is the device connected and mounted?)")
}

// isWindowsCIRCUITPY checks if a Windows drive has the CIRCUITPY volume label
func isWindowsCIRCUITPY(drivePath string) bool {
	// Check if drive exists and has a code.py or boot_out.txt (CircuitPython indicators)
	indicators := []string{"code.py", "boot_out.txt", "lib"}
	for _, indicator := range indicators {
		if _, err := os.Stat(filepath.Join(drivePath, indicator)); err == nil {
			return true
		}
	}
	return false
}

// GeneratePythonConfig generates the Python config file content
func GeneratePythonConfig(cfg *config.Config) (string, error) {
	var sb strings.Builder

	// Header
	sb.WriteString("# config.py - Auto-generated by camel-pad, do not edit manually\n")
	sb.WriteString("# Re-generate with: camel-pad config-push\n\n")
	sb.WriteString("from adafruit_hid.keycode import Keycode\n\n")

	// Timing config
	sb.WriteString("TIMING = {\n")
	fmt.Fprintf(&sb, "    \"double_press_window_ms\": %d,\n", cfg.Timing.DoublePressWindowMs)
	fmt.Fprintf(&sb, "    \"long_press_threshold_ms\": %d,\n", cfg.Timing.LongPressThresholdMs)
	sb.WriteString("}\n\n")

	// Button mappings
	sb.WriteString("BUTTONS = {\n")

	for _, btn := range cfg.Buttons {
		fmt.Fprintf(&sb, "    %d: {  # %s\n", btn.Index, buttonName(btn))

		if btn.Press != nil && len(btn.Press.Keys) > 0 {
			keycodes, err := keysToKeycodes(btn.Press.Keys)
			if err != nil {
				return "", fmt.Errorf("button %d press: %w", btn.Index, err)
			}
			fmt.Fprintf(&sb, "        \"press\": %s,\n", keycodes)
		}

		if btn.DoublePress != nil && len(btn.DoublePress.Keys) > 0 {
			keycodes, err := keysToKeycodes(btn.DoublePress.Keys)
			if err != nil {
				return "", fmt.Errorf("button %d double_press: %w", btn.Index, err)
			}
			fmt.Fprintf(&sb, "        \"double_press\": %s,\n", keycodes)
		}

		if btn.LongPress != nil && len(btn.LongPress.Keys) > 0 {
			keycodes, err := keysToKeycodes(btn.LongPress.Keys)
			if err != nil {
				return "", fmt.Errorf("button %d long_press: %w", btn.Index, err)
			}
			fmt.Fprintf(&sb, "        \"long_press\": %s,\n", keycodes)
		}

		sb.WriteString("    },\n")
	}

	sb.WriteString("}\n")

	return sb.String(), nil
}

func buttonName(btn config.Button) string {
	if btn.Name != "" {
		return btn.Name
	}
	return fmt.Sprintf("button %d", btn.Index)
}

// keysToKeycodes converts a list of key strings to a Python list of Keycodes
// Each key string can be a combo like "ctrl+c" which becomes [Keycode.CONTROL, Keycode.C]
// Multiple key strings become a list of lists: [["ctrl+c"], ["enter"]] -> [[Keycode.CONTROL, Keycode.C], [Keycode.ENTER]]
func keysToKeycodes(keys []string) (string, error) {
	if len(keys) == 1 {
		// Single key/combo - return flat list
		keycodes, err := ParseKeyToKeycodes(keys[0])
		if err != nil {
			return "", err
		}
		return formatKeycodeList(keycodes), nil
	}

	// Multiple keys - return list of lists (sequence)
	var parts []string
	for _, key := range keys {
		keycodes, err := ParseKeyToKeycodes(key)
		if err != nil {
			return "", err
		}
		parts = append(parts, formatKeycodeList(keycodes))
	}

	return "[" + strings.Join(parts, ", ") + "]", nil
}

func formatKeycodeList(keycodes []string) string {
	var parts []string
	for _, kc := range keycodes {
		parts = append(parts, "Keycode."+kc)
	}
	return "[" + strings.Join(parts, ", ") + "]"
}
